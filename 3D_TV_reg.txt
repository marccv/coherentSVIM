
    
    @time_it
    def invert_and_denoise3D_v2(self, base = 'sq', mu = 0.01, lamda = 0.3, niter_out = 50, niter_in = 3):
        
        self.base = base
        
        self.transform = t_6090.dct_6090(self.disp_freqs)
        self.transform.create_space()
    
        if base == 'cos':
            self.transform.create_matrix_cos()
            
        elif base == 'sq':
            self.transform.create_matrix_sq()
        
        nz,ny,nx = self.imageRaw.shape
        shape = (nz,ny,nx)
        M = self.transform.matrix
        M = M.astype(float)
        
        def Op(v):
            v = v.reshape( nz, int(len(v)/nz))
            return (M@v).ravel()
        
        def Op_t(v):
            v = v.reshape( nz, int(len(v)/nz))
            return (M.transpose()@v).ravel()
        
        Op_s = LinearOperator((nz*nx*ny, nz*nx*ny), matvec = Op, rmatvec  = Op_t,dtype = float)
        Op_s = pylops.LinearOperator(Op_s)
        
        
        
        Dop = [
            pylops.FirstDerivative(np.prod(shape), shape,  0, edge=True, kind="backward"),
            pylops.FirstDerivative(np.prod(shape), shape,  1, edge=True, kind="backward"),
            pylops.FirstDerivative(np.prod(shape), shape,  2, edge=True, kind="backward")
        ]
        
        # mu = 0.01
        lamda = [lamda]*3
        # niter_out = 50
        # niter_in = 3
        
        
        print(shape)
        # self.image_inv = np.zeros(shape)
        t = time.time()
        
        self.image_inv, _ = pylops.optimization.sparsity.SplitBregman(
                                    Op_s,
                                    Dop,
                                    self.imageRaw.ravel(),
                                    niter_out,
                                    niter_in,
                                    mu=mu,
                                    epsRL1s = lamda,
                                    tol=1e-4,
                                    tau=1.0,
                                    **dict(iter_lim=30, damp=1e-10)
                                )
        print(f'time for one line: {(time.time()  - t)/(shape[1] * shape[2])}')
        
        
        # self.image_inv.reshape(shape)
        
        self.denoised = True
        self.clipped = False
    
    
    